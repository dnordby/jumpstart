/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./assets/custom/product-bundle.ts":
/*!*****************************************!*\
  !*** ./assets/custom/product-bundle.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nlet maxValue = 0;\nconst inputs = [];\nconst cartGetUrl = `/cart.js`;\nconst cartAddUrl = `/cart/add.js`;\nconst priceUpdate = document.querySelector(\".js-running-total\");\nconst mediaList = document.querySelector(\".product__media-list\");\nconst bundleForm = document.querySelector(\"#product__form-bundle\");\nconst errorMessage = bundleForm === null || bundleForm === void 0 ? void 0 : bundleForm.querySelector(\".error-message\");\nconst bundleOptions = bundleForm === null || bundleForm === void 0 ? void 0 : bundleForm.querySelectorAll(\".product__form-option\");\nconst submitButton = bundleForm === null || bundleForm === void 0 ? void 0 : bundleForm.querySelector(\".js-bundle-submit\");\nconst boxQuantity = bundleForm === null || bundleForm === void 0 ? void 0 : bundleForm.querySelector(\".js-box-quantity\");\nconst loader = submitButton.querySelector(\".loading__spinner\");\nconst cart = document.querySelector(\"cart-notification\") ||\n    document.querySelector(\"cart-drawer\");\nconst getCart = () => __awaiter(void 0, void 0, void 0, function* () {\n    const cart = yield (yield fetch(cartGetUrl)).json();\n    return cart;\n});\nconst ProductBundle = () => __awaiter(void 0, void 0, void 0, function* () {\n    const validateCount = () => {\n        let total = 0;\n        let message = \"\";\n        let maxExceeded = false;\n        let minUnmet = false;\n        inputs.forEach((input) => {\n            total += Number(input.value);\n        });\n        if (total > maxValue) {\n            message = `You have selected ${total} choices. Please review and remove ${total - maxValue}!`;\n            maxExceeded = true;\n            minUnmet = false;\n            submitButton === null || submitButton === void 0 ? void 0 : submitButton.setAttribute(\"disabled\", \"\");\n            boxQuantity === null || boxQuantity === void 0 ? void 0 : boxQuantity.setAttribute(\"disabled\", \"\");\n        }\n        else if (total < maxValue) {\n            const pluralizedMessage = total > 1 ? \"options\" : \"option\";\n            message = `You have only selected ${total} ${pluralizedMessage}. Please pick ${maxValue - total} more!`;\n            maxExceeded = false;\n            minUnmet = true;\n            submitButton === null || submitButton === void 0 ? void 0 : submitButton.setAttribute(\"disabled\", \"\");\n            boxQuantity === null || boxQuantity === void 0 ? void 0 : boxQuantity.setAttribute(\"disabled\", \"\");\n        }\n        else {\n            message = \"All selections have been made\";\n            maxExceeded = false;\n            minUnmet = false;\n            submitButton === null || submitButton === void 0 ? void 0 : submitButton.removeAttribute(\"disabled\");\n            boxQuantity === null || boxQuantity === void 0 ? void 0 : boxQuantity.removeAttribute(\"disabled\");\n        }\n        return {\n            isValid: total !== maxValue ? false : true,\n            maxExceeded,\n            minUnmet,\n            message,\n        };\n    };\n    const addErrorStates = (errorPayload) => {\n        if (errorPayload.maxExceeded) {\n            inputs.forEach((input) => {\n                var _a;\n                if (Number(input.value) === 0)\n                    return;\n                (_a = input === null || input === void 0 ? void 0 : input.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add(\"error\");\n            });\n        }\n        errorMessage.textContent = errorPayload.message;\n        errorMessage.classList.add(\"visible\");\n    };\n    const removeErrorStates = () => {\n        inputs.forEach((input) => {\n            var _a;\n            (_a = input === null || input === void 0 ? void 0 : input.parentElement) === null || _a === void 0 ? void 0 : _a.classList.remove(\"error\");\n        });\n        errorMessage.classList.remove(\"visible\");\n    };\n    const updatePricing = () => {\n        let runningTotal = 0;\n        inputs.forEach((input) => {\n            const value = Number(input.value);\n            const price = Number(input.dataset.price);\n            if (value > 0) {\n                runningTotal += price * value;\n            }\n        });\n        const formattedTotal = (runningTotal / 100).toFixed(2);\n        priceUpdate.textContent = formattedTotal.toString();\n    };\n    const toggleLoader = () => {\n        submitButton.toggleAttribute(\"disabled\");\n        boxQuantity.toggleAttribute(\"disabled\");\n        submitButton.classList.toggle(\"loading\");\n        loader.classList.toggle(\"hidden\");\n    };\n    const imageUpdates = () => {\n        const ulElement = document.querySelector(\".thumbnail-list\");\n        const liElements = ulElement.querySelectorAll(\".thumbnail-list__item button img\");\n        console.log(liElements);\n        [...bundleOptions].map((option) => {\n            const optionInput = option.querySelector(\"input\");\n            const imgUrl = option.querySelector(\"img\");\n            if (imgUrl) {\n                const source = imgUrl.src;\n                const matchedImage = [...liElements].filter((element) => element.src.split(\"&\")[0] === source)[0];\n                if (matchedImage) {\n                    const closestButton = matchedImage.closest(\"button\");\n                    optionInput.addEventListener(\"focus\", () => {\n                        closestButton.click();\n                    });\n                }\n            }\n        });\n    };\n    imageUpdates();\n    for (let index = 0; index < bundleForm.elements.length; index++) {\n        const element = bundleForm === null || bundleForm === void 0 ? void 0 : bundleForm.elements[index];\n        if (element instanceof HTMLInputElement &&\n            element.classList.contains(\"js-bundle-input\")) {\n            inputs.push(element);\n            element.addEventListener(\"selectionchange\", (event) => {\n                updatePricing();\n                removeErrorStates();\n                const countCheck = validateCount();\n                if (countCheck.maxExceeded || countCheck.minUnmet) {\n                    addErrorStates(countCheck);\n                }\n            });\n        }\n        else if (element instanceof HTMLInputElement &&\n            element.classList.contains(\"js-max-value\")) {\n            maxValue = Number(element.value);\n        }\n    }\n    bundleForm === null || bundleForm === void 0 ? void 0 : bundleForm.addEventListener(\"submit\", (event) => __awaiter(void 0, void 0, void 0, function* () {\n        event.preventDefault();\n        const countCheck = validateCount();\n        const finalBoxCount = Number(boxQuantity.value);\n        toggleLoader();\n        for (let index = 0; index < finalBoxCount; index++) {\n            if (countCheck.isValid) {\n                let newBoxId = 0;\n                const existingBoxes = [];\n                const currentCart = yield getCart();\n                if (currentCart.items.length > 0) {\n                    currentCart.items.map((item) => {\n                        if (!item.properties._isBundle)\n                            return;\n                        if (!existingBoxes.includes(item.properties._boxId)) {\n                            existingBoxes.push(item.properties._boxId);\n                        }\n                    });\n                }\n                if (existingBoxes.length > 0) {\n                    const sortedBoxIds = existingBoxes.sort((a, b) => a - b);\n                    const lastId = sortedBoxIds[sortedBoxIds.length - 1];\n                    newBoxId = lastId + 1;\n                }\n                else {\n                    newBoxId = 1;\n                }\n                const itemPayload = [];\n                const productHandle = bundleForm.dataset.producthandle;\n                const formData = new FormData(bundleForm);\n                const extractedFormData = Object.fromEntries(formData);\n                const asArray = Object.entries(extractedFormData);\n                const filteredForm = asArray.filter(([key, value]) => Number(value) !== 0);\n                filteredForm.map(([key, value]) => {\n                    itemPayload.push({\n                        id: key,\n                        quantity: Number(value),\n                        properties: {\n                            _isBundle: true,\n                            _productHandle: productHandle,\n                            _boxId: newBoxId,\n                        },\n                    });\n                });\n                const payload = {\n                    items: itemPayload,\n                    sections: \"cart-notification-product\",\n                };\n                yield fetch(cartAddUrl, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                    },\n                    body: JSON.stringify(payload),\n                })\n                    .then((response) => response.json())\n                    .then((response) => {\n                    const product = response.items[0];\n                    product.sections = response.sections;\n                    cart.renderContents(product);\n                })\n                    .catch((error) => {\n                    console.log(\"Error adding bundle to cart:\", error);\n                });\n            }\n            else {\n                alert(countCheck.message);\n            }\n        }\n        toggleLoader();\n    }));\n});\nexports[\"default\"] = ProductBundle();\n\n\n//# sourceURL=webpack://grim-delights/./assets/custom/product-bundle.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./assets/custom/product-bundle.ts"](0, __webpack_exports__);
/******/ 	
/******/ })()
;